

<h3> <b>(E1)</b> Bypassing passkey entry in legacy pairing</h3> 

<p align="justify">
Among the four association methods, passkey entry is considered secure against Man-in-the-Middle (MitM) attacks. In this method, the initiating device displays a randomly generated value, which the responding device has to enter. Particularly, after the central sends a <i>PairConfirmSend</i> message, a prompt is shown on the peripheral device for passkey entry. In LE legacy pairing, the peripheral device shall send a <i>PairRandomSend</i> only if the <i>confirm</i>value (C_<sub>cmp</sub>) computed on the device matches the <i>confirm</i> value (C_<sub>rcv</sub>) received from the central device , i.e., when C_<sub>cmp</sub> = C_<sub>rcv</sub>. Otherwise, the responding device would terminate the pairing. <b>BLEDiff</b>, however, has uncovered 13 implementations where the device completes pairing and bonding without requiring to enter the passkey in the device and  thereby effectively nullifying all the security protections against MitM attacks.  
</p>


<div align="center">
  <img src="assets/figures/ble-issue4.png" alt="Passkey entry bypass" align="center"/> <br>
  Fig.: Passkey entry bypass
</div>

<p align="justify">
In this deviation, if the central sends a <i>PairRandomSend</i>, setting the value of the user input passkey to zero, the deviating BLE peripheral implementation responds with a <i>PairRandomSend</i>, without sending a <i>PairConfirmSend</i> message and even before taking the input from the user (deviating from the standards). The connection persists even after the user inputs the passkey after an attack with the deviation is performed. Furthermore, the peripheral implementation completes the pairing and bonding process and enables encryption, all assuming the user input to be zero. Surprisingly, one of the devices (Pixel 4a) does not even show the prompt for passkey entry, thus effectively bypassing the MitM protection put into place through the passkey entry association method. This issue has been assigned .  
<br>
The root cause of this issue can be attributed to implementation deviating from the specification. The BLE specification clearly states that if the confirm values do not match, the peripheral should not proceed with pairing. 
<br>
Due to this passkey entry bypass, it is possible for the attacker to perform a MitM attack on the vulnerable BLE devices. As the key value, <i>TK</i>, is always set to zero for the vulnerable peripheral, the attacker can impersonate both legitimate central and peripheral devices. In a hindsight, this is actually worse than just works association method as the user thinks they are using a high level of protection, but actually, they are not.
</p>



<h3><b>(E2)</b> Bypassing Out-Of-Band authentication</td> </h3> 

<p align="justify">
During pairing, an out-of-band (OOB) channel, e.g., NFC may be used to communicate information between central and peripheral, which is further used later in the pairing process. The <i>OOB data flag</i> shall be set if a device has the peer device's out-of-band authentication data. A device uses the peer device's out-of-band authentication data to authenticate the peer device. More specifically, after public key exchange when a device receives the OOB confirm value, if the confirm value does not match, or the peripheral does not have the central's OOB data, then the device should immediately abort the pairing process by sending <i>PairFailed</i> message. However, <b>BLEDiff</b> found 6 implementations where without receiving any OOB confirm data, the peripheral devices proceed to the next step, i.e., random value exchange, completely bypassing the authentication. To make matters worse, the implementations even pass <i>DHKeyCheckSend</i> with <i>rb</i> set to zero and complete pairing and bonding altogether.
</p>

<div align="center">
  <img src="assets/figures/ble-issue3.png" alt="Out-of-Band pairing bypass" align="center"/> <br>
  Fig.: Out-of-Band pairing bypass
</div>

<p align="justify">
The root cause of this issue is that the implementation is deviating from standards. In the specification, it is mandated that if the confirm value received from OOB does not match the calculated value, the peripheral will abort the pairing process
<br>
An attacker in the radio range can abuse this vulnerability to completely bypass OOB authentication in the affected BLE devices, which rely on secure connections with out-of-band data to protect user privacy.  As the OOB authentication is bypassed, an attacker can send the usual BLE packets, impersonate both the legitimate central and peripheral, and perform MitM attacks on BLE connections. 
</p>


<h3> <b>(E3)</b> Bypassing legacy pairing </h3> 

<p align="justify">
In this deviation, it is possible to bypass the legacy pairing procedure and start encryption on a device. During legacy pairing, an implementation exchanges random values and confirms the values to generate Short Term Keys (<i>STK</i>). Without these procedures, an implementation cannot move to the encryption procedure. However, for the affected devices, the implementations  skip part of the pairing procedures and directly proceed to encryption. In the specification, the flow of pairing is clearly attributed, and hence starting the encryption procedure without even completing the pairing is a deviation from the standards. For exploiting this deviation in an attack, an attacker in the radio range can skip the pairing procedure and directly start encryption and try to bypass BLE security.
</p>

<div align="center">
  <img src="assets/figures/ble-issue2.png" alt="Legacy pairing bypass" align="center"/> <br>
  Fig.: Legacy pairing bypass
</div>

<p align="justify">
There are two impacts of this deviation. The first impact is that it can cause security bypass due to low-entropy key size. The <i>STK</i>is generated using <i>s1 = (k, r1, r2)</i>. Each of these parameters are 128-bit long. In the key generation phase, 64 bits of <i>r1</i> and 64 bits of <i>r2</i> are discarded to create a 128-bit input, which together with <i>k</i> generates the <i>STK</i>. In case the pairing procedures are bypassed, and with no input and no output capability (<i>k=0</i>), the implementation generates a key with only the 64-bits of <i>r2</i>, thus generating a key with much smaller entropy. This can potentially lead to a security bypass. For other I/O capabilities, the entropy will be higher with different <i>k</i> value, but lower than the envisioned entropy when random values are exchanged. The second impact is DoS. As part of pairing can be bypassed (including authentication), an attacker can start encryption without completing the authentication. In case the attacker is unable to figure out the low-entropy key, there is a key-mismatch and the connection is dropped. Since  an attacker can drop a connection without authentication, this can cause a DoS.

</p>


<h3> <b>(E4)</b> Accepts <i>DHKeyCheckSend</i> with all fields zero </h3> 

<p align="justify">
In this deviation, during BLE secure pairing, the BLE implementations respond  to <i>DHKeyCheckSend</i> message with <i>MacKey, Na</i>, and <i>Nb</i> set to zero. This behavior deviates from the standards as the implementations fail to properly check the confirmation value. As specified in the standard, if the confirmation value check fails, it indicates that the initiating device has not confirmed the pairing, and the protocol must be aborted.
</p>

<div align="center">
  <img src="assets/figures/ble-issue1.png" alt="Invalid DHKey Check" align="center"/> <br>
  Fig.: Invalid DHKey Check
</div>

<p align="justify">
Due to this noncompliance, it is possible for an attacker to inject the <i>DHKeyCheckSend</i> packet with <i>MacKey, Na</i>, and <i>Nb</i> set to zero during the pairing procedure, forcing the vulnerable device to stop communicating with a specific central device and causing DoS. Furthermore, this deviation can be a stepping stone for a much more severe issue as illustrated below. After <i>DHKeyCheckSend</i>, the encryption procedure is started which uses the generated <i>LTK</i> to encrypt subsequent packets. The task of the <i>DHKeyCheckSend</i> is to ensure the right key is generated. In case <i>DHKeyCheckSend</i> fails, the subsequent <i>LTK</i> is discarded due to security reasons. Since it is possible to bypass <i>DHKeyCheckSend</i> by setting <i>MacKey, Na</i>, and <i>Nb</i> to zero, the attacker may exploit it to bypass the security partially as well.

</p>



<h3> <b>(E5)</b> Unresponsiveness with <i>PauseEncRespPlainText</i> </h3> 

<p align="justify">
The deviation happens when a BLE device receives a plaintext <i>PauseEncResp</i>. Even before pairing, if the BLE implementation receives <i>PauseEncRespPlainText</i>, then it crashes and becomes unresponsive. This is a clear deviation from the standards. In case a device handles an invalid packet, there are three ways to handle it (i) ignoring the packet, (ii) sending rejection, (iii) terminating the connection. However, in this case, the packet causes a fault in the implementation.
<br>
It is possible to cause DoS by sending this packet to the implementation. The packet is plaintext and does not have integrity protection; therefore, it can be sent by an attacker anytime to an existing  BLE connection. Moreover, the packet does not show any prompt on the smartphone and turns off the Bluetooth for some time. It seems the packet causes restart of the Bluetooth daemon of the device. Therefore, sending such packets in a loop can create permanent DoS without any notification to the user.
</p>


<h3> <b>(E6)</b> Unresponsiveness with <i>ConReqTimeoutZero</i> and <i>ConReqIntervalZero</i> </h3> 

<p align="justify">
When a device receives a <i>ConReq</i> with the <i>timeout</i> field set to zero, the device becomes completely unresponsive. A user has to manually turn on the Bluetooth service to make the device responsive. A similar attack with invalid connection requests was shown in <a href="https://asset-group.github.io/disclosures/sweyntooth/"> SweynTooth </a> on two development boards. We have found this issue in 5 different smartphones and 3 different development boards. Furthermore, in their attack for the invalid connection request, both the interval and timeout fields have to be set to zero. In our case, the interval field does not matter; as long as the timeout field is set to zero, the device becomes unresponsive and automatically turns off Bluetooth.
<br>
An attacker in the radio range can exploit the issue to cause a surreptitious denial of service of the Bluetooth. Though this attack is on BLE, the smartphone turns off both BLE and BR/EDR without notifying the user. To resolve this, the user has to manually restart BLE and, in some cases, the smartphone altogether.
</p>